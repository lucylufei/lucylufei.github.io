<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>
        Lufei - Life
    </title>

    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100;0,300;0,400;0,600;0,700;1,400&display=swap" rel="stylesheet">
    <link rel="icon" href="../images/L.png">
    <link rel="stylesheet" href="../common.css">
    <link rel="stylesheet" href="../topbutton.css">
    <link rel="stylesheet" href="./projects.css">

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous">
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
        integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous">
    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous">
    </script>
    <script>
        (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-102991991-1', 'auto');
        ga('send', 'pageview');
    </script>
    <script>
        $(document).ready(function () {

            var myIframe = document.getElementById('iframe');
            console.log(myIframe)
            myIframe.addEventListener("load", function () {
                var x = 0;
                var intervalID = setInterval(function () {
                    console.log($(".container").height())
                    $("#iframeBlocker").height($("#iframe").height())
                    if (++x === 5) {
                        window.clearInterval(intervalID);
                    }
                }, 500);
            });
        })
    </script>
    <script>
        $(document).scroll(function () {
            // Identify scrolled distance
            var y = $(this).scrollTop();

            var trigger = 100;

            if (y >= (trigger)) {
                $('#topbtn').fadeIn();
            } else {
                $('#topbtn').fadeOut();
            }
        });
        $(document).ready(function () {
            $("#topbtn").click(function () {
                jQuery('html,body').animate({
                    scrollTop: 0
                }, 0);
            });
        });
    </script>
    <style>
        #topbtn {
            display: none;
            border: 1px solid;
            background-color: white;
            color: #998E96;
            cursor: pointer;
            padding: 0.75em;
            position: fixed;
            bottom: 2em;
            right: 2em;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <!-- Nav Bar -->
    <nav class="navbar sticky-top navbar-expand-lg shadow-sm">
        <a class="navbar-brand" href="../index.html" style="font-size: 2em;">Lufei</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText"
            aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarText">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item">
                    <a class="nav-link text-center" href="../resume.html">Resume</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link text-center active" href="../project.html">Projects</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link text-center" href="../menu.html">Life</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link text-center" href="../lululetter.html">lululetter</a>
                </li>
            </ul>
        </div>
    </nav>
    <div class="container" style="min-height: 70vh;">
        <div class="header" style="text-align: center;">
            <h1>Magnetic Field Tracking Robot</h1>
        </div>
        <div style="text-align: center;">
            <p class="subtitle">ELEC 291 Project</p>
        </div>
        <hr>
        <div style="text-align: center;">
            <img src="../images/rover.JPG" alt="..." style="width: 500px; max-width: 75vw;">
        </div>
        </br>
        <h2>Project Summary</h2>
        <hr>
        <div>
            <p>Our goal for this project was to design a robot that can track and follow a path defined by a electromagnetic guide wire. We design one controller to generate a magnetic field from the wire, with different frequencies to signal different commands. A separate controller is used for the robot, which detects the magnetic field using a circuit built with inductors and turns with PWM motors.</p>
            
        </div>
        <h5>Magnetic Guide Wire</h5>
        <div>
            <p>We are prohibited to communicate with the guide wire tracking robot via wired communication such as direct control, SPI, etc. We are also prohibited from using RF (wireless) communication such as bluetooth, WiFi, infrared, etc. Thus, in order to send commands to the robot, the only option is through the guide wire. When proper input is given by the user, commands are sent through the guide wire every 1 second. </p>
            <p>To start sending commands, which are comprised of bits, the 16kHz is first turned off for 64.0ms. This counts as a "0" bit and tells the track robot to start receiving bits. Then the 16kHz is turned back on for 64.0ms to synchronize timing on the track robot, allowing the following bits to be read consistently. </p>
            <p>The next three bits are the "real" data bits that contains the command code. Since we are sending 6 commands, 3 bits (maximum 8 different commands) are deemed appropriate. The 16kHz signal will be turned on or off depending on if the bit that is currently being sent is 0 or 1. Their transfer rates are all also 64ms per bit.</p>
        </div>
        <h5>User IO</h5>
        <div>
            <p>User determines the commands being sent to the robot using buttons and a joystick. The joystick is basically an assembly of two potentiometers and they are connected to Analog 0 (A0) and Analog 1 (A1) pins on the ATMega328 microcontroller. The x-axis and y-axis analog signal is read by the onboard ADC. Two buttons are connected to two digital input pins for two more commands.An LCD is attached to the guide wire generator to display the current command being sent. If no command is given, the LCD will display “Awaiting commands”. The attached LED also strobes the individual bits when the microcontroller is transmitting a command.</p>
        </div>
        <h5>Receiving Commands</h5>
        <div>
            <p>In order to receive commands quickly and consistently, we chose to use a digital input rather than an analog input (ADC reading). The software algorithm set two requirements for the hardware: the receiver must receive commands at 15.625Hz (64.0ms per bit) , and the input voltage must meet the requirements for a digital reading (0V signaling logic 0 and 5V signaling logic 1). Based on these two requirements, we designed our receiver using a combination of two comparators and one rectifier circuit. </p>
            <p>The first comparator has two functions. First, it transforms a sine wave to a steady square wave. Second, and more importantly, it separates the current from other circuits (e.g. peak detector).</p>
            <p>We first tested our receiver circuit without utilizing this comparator and found that the rectifier drains current from other parts of the circuits. It was noted that this had a large negative effect on ADC readings from the peak detector. The rectifier transforms the AC square wave to a DC signal. The AC square wave at 16kHz must be smoothed out by a capacitor to a steady DC signal. At the same time, the capacitor must also discharge fast enough to differentiate the “on” and “off” DC signals from turning on and off the AC square wave at 15.625 Hz. We tested different capacitors to determine the best fit for this requirement and concluded that using 4.7μF capacitor was the best fit. Command transmissions from the guide wire controller were also slowed down from 100Hz to 15.625Hz.</p>
            <p>Since the maximum voltage coming out from the rectifier while transmitting is 2.2V, which is far less than the 5 V necessary to indicate logic 1, we decided to use another comparator to boost the maximum voltage while maintaining the same frequency. This allowed us to meet the software requirements without compromising any other parts of the circuit.</p>
            <p>Each incoming command from the guide wire begins with a logic 0 detected by an input from the comparator. This triggers the robot to actively read the binary sequence that follows. Commands are read through sampling. Each binary bit is sent for a period of exactly 64.0ms, and the most accurate way to read the bit is at the midpoint of 32.0ms.</p>
            <p>There is a logic 0 bit followed by a logic 1 bit which acts as a accurately timed trigger before each command. To offset the delay of polling for logic 0, the robot will wait for a logic 1 once the function has been triggered. This essentially synchronizes the robot with the guide wire controller. The robot then commences receiving the incoming bit sequence with the correct timing. This method allowed us to easily adjust the code to match the baud rate of transmitted data.</p>
            <h6>Example</h6>
            <p>The robot will be triggered by a logic 0, followed by a logic 1 to synchronize timing. Next, the function will wait for 96.0ms (1.5 times 64.0ms) to be at the center of the next bit, and 64.0ms to be at the center of each following bit. The function reads 4 consecutive bits, stores them into a single 8-bit variable, and compares it against the database of commands. Finally, the command is returned if it matched with a known command, or the previous command is returned if an invalid command.</p>
        </div>
        <h5>Robot Control</h5>
        <div>
            <p>In each loop, the robot checks for sonar readings. If an object is picked up by the sonar to be less than 7 cm away, the robot will execute the stop function as a safety measure and wait until the object has been removed to resume its previous state.</p>
            <p>Also in each loop, the current command of the robot or the state stopped is displayed onto an LED matrix. In the case of left and right turns, signal LED lights are set to blink. While the command is 0 the robot is also searching for intersections. The combined high voltages of the inductors signal an intersection and trigger a function that ensures the robot continues straight through the intersection.</p>
            <p>To control the speed of the motors, we used Pulse-width modulation (PWM) operated by an H-bridge. As a result of changing the duty cycle of the square wave outputted to the H-Bridge circuits, the speed of the motors change.</p>
            <p>When a left turn or right turn command is sent while moving forwards, it does not execute until an intersection has been detected. Once the code has been activated by an intersection, the robot first moves straight forwards for 300 ms until it is directly on top of the intersection. Then, one motor is set to 50 PWM forwards while the other is set to 0, allowing the robot to pivot in place. The robot turns for 200 ms in order to move the rear inductors off the current track, and continues to turn until the rear detectors sense the new track. From here, the robot continues on with its current state.</p>
            <p>Turns while moving backwards are similar; they are executed only once an intersection has been detected. The difference is that the robot will move backwards to be directly on top of the intersection and the PWM is set in the opposite direction. The command is still dependent on the rear inductors to sense the new track. The rear inductors were chosen to sense the end of a turn because they are farther from the wheels, thus farther from the intersection and reading more accurate voltage values.</p>
        </div>
    </div>
    <!-- Return to Top Button -->
    </br>
    <button id="topbtn" style="margin:0 auto;">Back to Top</button>
    </br>
</body>


<!-- Footer -->
<footer>
    <div id="page_content">
        <a href="https://www.facebook.com/lululufei" target="_blank"> <i
                class="fa fa-facebook-official w3-hover-opacity" style="font-size:24px;"></a></i>&nbsp;&nbsp;&nbsp;
        <a href="http://instagram.com/lululetter" target="_blank"> <i class="fa fa-instagram w3-hover-opacity"
                style="font-size:24px;"></a></i>&nbsp;&nbsp;&nbsp;
        <a href="http://www.linkedin.com/in/lufei-liu-b8913b106" target="_blank"> <i
                class="fa fa-linkedin w3-hover-opacity" style="font-size:24px;"></i> </a>
        </br>
        <p>me@lufei.ca</p>
    </div>
</footer>

</html>